// Реализовать аналог библиотеки Math (можно назвать MathX) с базовым набором функций, используя замыкания:
// вычисление N-го числа в ряду Фибоначчи
// вычисление всех чисел в ряду Фибоначчи до числа N
// вычисление N-го просто числа
// вычисление всех простых чисел до числа N

// Создаём моудь MathX, в который записываем необходимые методы

const MathX = {
  // метод для расчёта n-го числа в ряду Фибоначи, записываем предудущее и текущее значение, первые 2 числа (1, 1) записываем в эти переменные, так как их не получится расчитать через алгоритм
  fibonachi: function (n) {
    let prev = 1;
    let cur = 1;

    // Если n=1, возвращаем prev, так как это первое число в нашем ряду
    if (n === 1) {
      return prev;
    }

    // Проходимся циклом начиная с i=2, тогда если n=2, прохождения по циклу не будет, на каждой итерации прибавляем к предыдущему значению текущее, и присваиваем предыдущему значение текущее, а текущему новое текущее
    for (let i = 2; i < n; i++) {
      let newCur = prev + cur;
      [prev, cur] = [cur, newCur];
    }

    // Возвращаем текущее значение
    return cur;
  },

  // метод для расчёта всех чисел до n в ряду Фибоначи, записываем предудущее и текущее значение в массив, первые 2 числа (1, 1) записываем в исходный масив, так как их не получится расчитать через алгоритм
  fibonachiAll: function (n) {
    const res = [1, 1];

    // Если n=1, возвращаем первое число в массиве, так как это первое число в нашем ряду
    if (n === 1) {
      return res[0];
    }
    
    // Проходимся циклом начиная с i=2, тогда если n=2, прохождения по циклу не будет и вернётся изначальный массив, на каждой итерации прибавляем к предыдущему значению текущее и записываем новое значение в массив
    for (let i = 2; i < n; i++) {
      res.push(res[i - 1] + res[i - 2]);
    }

    // Возращаем массив, объединив его в строку с разделителем ", " методом join
    return res.join(", ");
  },

  // Для расчёта простого числа вводим дополнительный метод, которыйф будет принимать число и возращать true в случае если чило простое и false в обратном случае
  checkSimpleNum: function (num) {
    // 1 не является простым числом, так как  имеет только 1 делитель
    if (num === 1) {
      return false;
    }

    // так как всё чётные числа делятся на 2, то есть все кроме числа 2 не подходят под условия простого числа, мы сначала проверяем является ли число 2 и возвращаем true, потом проверяем является ли число чётным и если да, возвращаем false (если бы была 2ка return в предыдущем условии уже бы вышел из функции)
    if (num === 2) {
      return true;
    }

    if (num % 2 === 0) {
      return false;
    }

    // Каждое число делится на себя и единицу, поэтому в качестве делителей имеет смысл проверять числа начиная с 2 до исходного числа - 1. Если число не делится на числа меньше или равно корню из числа, то у него нет других делителей, так как они были бы парой к этим значениям, проверять больше корня из числа нет смылса. Проверять чётные числители не имеет смысла, так как на чётные делители делятся только чётные числа, которые мы исключили. Если в число делится на какое-то i возвращаем false.
    for (let i = 3; i <= Math.sqrt(num); i+=2) {
      if (num % i === 0) {
        return false;
      }
    }
    // Если ни одно из условий не сработало, возвращаем true
    return true;
  },

  simpleNum: function (n) {
    // count - счётчик простых чисел, cur текущее значение
    let count = 0;
    // 1 не является простым числом, так как  имеет только 1 делитель, в текущее значение cur записываем 2, будем проверять начиная с него
    let cur = 2;
    
    // До тех пор пока счётчик не будет равен заданному n, на каждой итерации цикла while проверяяем является ли число простым с помощью метода checkSimpleNum, если являеется увеличиваем счётчик на 1, на каждой итерации увеличиваем текущее значение на 1
    while (count !== n) {
      if (this.checkSimpleNum(cur)) {
        count++;
      }
      cur++;
    }
   
    // после выхода из цикла возвращаем текущее значение - 1, так как после увеличения счётчика и текущее значение в любом случае успело увеличится на 1
    return cur - 1;
  },

  simpleAllNum: function (n) {
    // count - счётчик простых чисел, cur текущее значение
    let count = 0;
    // 1 не является простым числом, так как  имеет только 1 делитель, в текущее значение cur записываем 2, будем проверять начиная с него
    let cur = 2;
    // В массив res будем записывать все простые числа
    let res = [];

    // До тех пор пока счётчик не будет равен заданному n, на каждой итерации цикла while проверяяем является ли число простым с помощью метода checkSimpleNum, если являеется увеличиваем счётчик на 1 и добавляем чило в результирующий массив, на каждой итерации увеличиваем текущее значение на 1
    while (count !== n) {
      if (this.checkSimpleNum(cur)) {
        res.push(cur);
        count++;
      }
      cur++;
    }

    // Возращаем массив простых сиел, объединный его в строку с разделителем ", " методом join
    return res.join(", ");
  },
};

console.log(MathX.fibonachi(7)); // 13
console.log(MathX.fibonachiAll(7)); // 1, 1, 2, 3, 5, 8, 13
console.log(MathX.simpleNum(5)); // 11
console.log(MathX.simpleAllNum(5)); // 2, 3, 5, 7, 11
